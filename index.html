<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9827255236053335"
     crossorigin="anonymous"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DLsiteおすすめ共有|みんなで投稿・評価する作品シェアサイト</title>

    <meta name="keywords" content="DLsite, おすすめ, 共有, ランキング, 同人ゲーム, 漫画">

    <meta property="og:url" content="https://dlsite-share.com/">
    <meta property="og:type" content="website">
    <meta property="og:title" content="DLsiteおすすめ共有|みんなで投稿・評価する作品シェアサイト">
    <meta property="og:description" content="DLsiteのおすすめ作品をみんなで共有・評価できるサイトです。新着やランキングからお気に入りを探そう！">
    <meta property="og:site_name" content="DLsiteおすすめ共有">
    <meta property="og:image" content="https://dlsite-share.com/ogp-image.png">
    <meta name="twitter:card" content="summary_large_image">
    <link rel="canonical" href="https://dlsite-share.com/">

    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="shortcut icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <style>
 /* ==========================================================================
    1. 基本設定 (リセット、全体レイアウト、タイポグラフィ)
    ========================================================================== */

 /* 全ての要素に適用する基本的なリセット */
 * {
    box-sizing: border-box; /* paddingとborderをwidth/heightに含める */
    margin: 0;
    padding: 0;
 }

 /* ページ全体の基本的なスタイル */
 body {
    font-family: sans-serif;
    background: #f5f5f5;
    color: #333;
 }

 /* サイト全体のコンテンツを中央に配置するラッパー */
 .container {
    max-width: 960px;
    margin: 2rem auto;
    padding: 0 1rem;
 }

 /* h2, hr などの共通要素 */
 h2 {
    margin: 0;
    padding: 0;
    border: none;
    display: flex;
    align-items: center;
    gap: 0.5rem;
 }

 hr {
    border: none;
    border-top: 1px solid #eee;
    margin: 2rem 0;
 }

 /* ==========================================================================
    2. 汎用・ユーティリティクラス
    ========================================================================== */

 /* 要素を非表示にするための汎用クラス */
 .hidden {
    display: none !important;
 }

 /* 読み込み中を示すスピナーアニメーション */
 .loading {
    position: relative;
 }
 .loading::after {
    content: '';
    position: absolute;
    top: 50%;
    right: 10px;
    width: 16px;
    height: 16px;
    margin-top: -8px;
    border: 2px solid #fff;
    border-top-color: transparent;
    border-radius: 50%;
    animation: spin .6s linear infinite;
 }

 /* スピナーの回転アニメーション定義 */
 @keyframes spin {
    to {
        transform: rotate(360deg);
    }
 }
 
 /* 作品画像のモザイク表示 */
 body.mosaic-on .item img {
    filter: blur(8px);
    transition: filter 0.2s ease-in-out;
 }
 body.mosaic-on .item img:hover {
    filter: blur(0);
 }
 /* 詳細情報ポップアップ */
 #details-popup {
    display: none; /* 通常は非表示 */
    position: absolute; /* マウス位置に追従させる */
    z-index: 5000; /* 他の要素より手前に表示 */
    background-color: #fff;
    border: 1px solid #ccc;
    border-radius: 6px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    padding: 1rem;
    max-width: 350px;
    pointer-events: none; /* ポップアップ自体がマウスイベントの邪魔をしないように */
    transition: opacity 0.1s ease-in-out;
 }

 /* ポップアップ内のタイトル */
 #details-popup h4 {
    font-size: 1rem;
    margin-top: 0;
    margin-bottom: 0.5rem;
 }

 /* ポップアップ内のタグ一覧 */
 #details-popup .popup-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
 }

 /* ポップアップ内のタグ */
 #details-popup .popup-tag {
    background-color: #e0e0e0;
    padding: 3px 7px;
    border-radius: 4px;
    font-size: 0.8rem;
 }

 /* ==========================================================================
    3. ヘッダーとナビゲーション
    ========================================================================== */
 
 /* サイトヘッダー */
 .site-header {
    text-align: center;
    margin-bottom: 2rem;
 }
 .site-header h1 {
    font-size: 2.5rem;
    margin-bottom: 0.5rem;
 }
 .site-header p {
    font-size: 0.8rem;
    color: #888;
 }
 
 /* 認証エリア（ログイン/ログアウト） */
 .auth-area {
    text-align: right;
    margin-bottom: 1rem;
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 1rem;
 }
 .auth-area #userName {
    font-weight: bold;
 }
 .auth-area button {
    padding: .4rem .8rem;
    background-color: #007bff;
    color:white;
    border:none;
    border-radius: 4px;
    cursor: pointer;
 }
 .auth-area button#logoutBtn {
    background-color: #6c757d;
 }
 .requires-auth:disabled {
    opacity: 0.5;
    cursor: not-allowed;
 }
 
 /* メインナビゲーション */
 .main-nav {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid #eee;
    align-items: center;
 }
 .main-nav button {
    padding: .5rem 1rem;
    background: #555;
    color: white;
    border: none;
    border-radius: 4px;
    font-size: 1rem;
    cursor: pointer;
    white-space: nowrap;
 }
 .main-nav button.active {
    background: #000;
    font-weight: bold;
 }
 .hamburger-btn {
    font-size: 1.5rem;
    padding: 0 .8rem;
    background-color: #555;
    display: none; /* PCでは非表示 */
 }

 /* モバイル用メニュー */
 .mobile-menu {
    background-color: #fff;
    border: 1px solid #ddd;
    border-radius: 6px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    margin-bottom: 1rem;
    overflow: hidden;
 }
 .mobile-menu button {
    display: block;
    width: 100%;
    padding: .75rem 1rem;
    background: none;
    border: none;
    border-bottom: 1px solid #eee;
    text-align: left;
    font-size: 1rem;
    color: #333;
    cursor: pointer;
 }
 .mobile-menu button:last-child {
    border-bottom: none;
 }
 .mobile-menu button:hover {
    background-color: #f5f5f5;
 }


 /* 各ビューのコンテナ */
 .view-container {
    display: none;
 }
 #view-favorites, #view-mylists, #view-public-list {
    padding-bottom: 2rem;
 }
 
 /* ==========================================================================
    4. セクションと操作コントロール
    ========================================================================== */

 /* 各セクションの見出し */
 .section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 2px solid #ccc;
    padding-bottom: 0.5rem;
    margin-top: 2.5rem;
 }

 /* 表示件数などのオプション */
 .view-options {
    display: flex;
    align-items: center;
    gap: 0.5rem;
 }
 .view-options label {
    font-size: 0.85rem;
    color: #555;
 }
 .view-options select {
    padding: 0.2rem 0.4rem;
    border: 1px solid #ccc;
    border-radius: 4px;
    background-color: #fff;
 }

 /* 開閉可能なセクション */
 .collapser-header {
    cursor: pointer;
    user-select: none;
 }
 .collapser-header h2::after {
    content: '▲';
    font-size: 0.8em;
    margin-left: 0.5em;
    display: inline-block;
    transition: transform 0.3s;
 }
 .collapser-header.collapsed h2::after {
    transform: rotate(180deg);
 }
 .collapsible-content {
    overflow: hidden;
    transition: max-height 0.4s ease-out, padding 0.4s ease-out, margin 0.4s ease-out;
    max-height: 5000px; /* 十分に大きい高さを指定 */
 }
 .collapsible-content.collapsed {
    max-height: 0;
    padding-top: 0 !important;
    padding-bottom: 0 !important;
    margin-top: 0 !important;
    margin-bottom: 0 !important;
 }
 
 /* URL入力欄やフィルターボタンなどの操作エリア */
 .controls {
    display: flex;
    flex-wrap: wrap;
    gap: .5rem;
    margin-bottom: 1rem;
    align-items: center;
 }
 .controls input {
    flex: 1;
    min-width: 200px;
    padding: .5rem;
    border: 1px solid #ccc;
    border-radius: 4px;
 }
 
 /* フィルター専用の操作エリア */
 .filter-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-bottom: 1rem;
 }

 /* 各種ボタンの共通スタイルと個別スタイル */
 .controls button, .filter-controls button {
    padding: .5rem 1rem;
    border: none;
    color: #fff;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s;
 }
 #addBtn { background: #28a745; }
 #addBtn:disabled { opacity: .6; cursor: default; }
 #hideBadBtn { background: #6c757d; }
 #hideBadBtn.active { background: #f44336; font-weight: bold; }
 #mosaicToggleBtn { background: #8e44ad; }
 .filterByTagsBtn, .resetFilterBtn { background: #4CAF50; color: white; }
 .filterByTagsBtn.active { background: #2E7D32; font-weight: bold;}
 #contactBtn { background-color: #007bff; color: white; }
 #infoBtn { background-color: #17a2b8; } /* サイト情報ボタン */
 
 /* ==========================================================================
    5. タブ UI
    ========================================================================== */

 .tabs input[type="radio"] {
    display: none; /* ラジオボタン自体は非表示 */
 }
 .tabs label {
    display: inline-block;
    padding: .5rem 1.5rem;
    cursor: pointer;
    background: #eee;
    margin-right: .5rem;
    border-radius: 4px 4px 0 0;
    font-weight: bold;
 }
 /* 選択されているタブのスタイル */
 #tab-admin_manga:checked ~ .tabs-container label[for="tab-admin_manga"],
 #tab-admin_game:checked ~ .tabs-container label[for="tab-admin_game"],
 #tab-new:checked ~ .tabs-container label[for="tab-new"],
 #tab-ranking:checked ~ .tabs-container label[for="tab-ranking"] {
    background: #fff;
 }
 .tab-content {
    display: none; /* タブの中身は通常非表示 */
    padding: 1rem;
    background: #fff;
    border: 1px solid #ddd;
    border-top: none;
    border-radius: 0 4px 4px 4px;
 }
 /* 選択されているタブの中身だけ表示 */
 #tab-admin_manga:checked ~ #admin_manga,
 #tab-admin_game:checked ~ #admin_game,
 #tab-new:checked ~ #new,
 #tab-ranking:checked ~ #ranking {
    display: block;
 }
 
 /* ==========================================================================
    6. 作品カード（グリッドとアイテム）
    ========================================================================== */
 
 /* カードを並べるグリッドレイアウト */
 .grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 1rem;
    transition: min-height 0.3s ease-in-out;
    align-content: start;
 }

 /* スケルトンローディング */
 .skeleton-card {
    background-color: #e0e0e0;
    border-radius: 6px;
    height: 320px;
    animation: pulse 1.5s infinite ease-in-out;
 }
 @keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.6; }
    100% { opacity: 1; }
 }


 /* 作品カードのコンテナ */
 .item {
    position: relative;
    background: #fafafa;
    border: 1px solid #ddd;
    border-radius: 6px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    height: 320px;
    transition: box-shadow 0.2s;
 }
 .item:hover {
    box-shadow: 0 4px 12px rgba(0,0,0,0.15); /* カーソルを合わせた時の影 */
 }

 /* カード内の各パーツ */
 .item img {
    width: 100%;
    height: 180px;
    object-fit: cover;
    flex-shrink: 0;
 }
 /* タイトルとタグをまとめる親要素 */
 .item-body {
    flex: 1;
    overflow-y: auto;
    padding: 0 .75rem .5rem .75rem;
 }

 /* タイトル */
 .title {
    font-size: .9rem;
    font-weight: bold;
    max-height: none;
    overflow-y: visible;
    margin: .75rem 0;
    cursor: pointer;
 }

 /* タグ全体のコンテナ */
 .tags {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    max-height: none;
    overflow-y: visible;
 }

 /* タグの見た目 */
 .tag {
    background: #e0e0e0;
    border-radius: 4px;
    padding: 4px 8px; 
    font-size: .75rem;
    line-height: 1.4; 
    display: inline-block; 
    margin-bottom: 4px;
 }
 .item-footer {
    margin-top: auto;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: .5rem;
    background: #fff;
    gap: 0.5rem;
    flex-shrink: 0;
    min-height: 38px;
 }

 /* Good/Bad 評価ボタン */
 .rating-buttons {
    display: flex;
    align-items: center;
    gap: 4px;
 }
 .rating-btn {
    padding: 2px 6px;
    font-size: .8rem;
    border: none;
    border-radius: 4px;
    background: #eee;
    cursor: pointer;
 }
 .rating-btn.good.active {
    background: #4caf50;
    color: #fff;
 }
 .rating-btn.bad.active {
    background: #f44336;
    color: #fff;
 }
 .score-display {
    visibility: hidden; /* ランキング以外では非表示 */
    font-size: 0.9rem;
    font-weight: bold;
    color: #333;
    margin-left: 0.5rem;
 }
 #rankingGrid .score-display {
    visibility: visible; /* ランキングタブでのみ表示 */
 }

 /* カード上のアクションボタン（お気に入り、リスト追加など） */
 .card-actions {
    display: flex;
    gap: 4px;
 }
 .card-actions button {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    border: 1px solid rgba(0,0,0,0.1);
    background-color: rgba(255, 255, 255, 0.8);
    cursor: pointer;
    font-size: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
 }
 .card-actions button:hover {
    background-color: white;
    transform: scale(1.1);
 }
 .card-actions .favorite-btn.favorited { color: #e91e63; background-color: white; }
 .card-actions .add-to-list-btn.in-list { color: #28a745; background-color: white; }
 .card-actions .remove-from-list-btn { color: #f44336; }

 /* ★ 変更: PC表示ではホバー時のみボタン表示 */
 .item .card-actions {
    position: absolute;
    top: 4px;
    right: 4px;
    z-index: 10;
    opacity: 0;
    pointer-events: none;
 }
 .item:hover .card-actions {
    opacity: 1;
    pointer-events: auto;
 }


 /* ページネーション */
 .pagination {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: .5rem;
    margin-top: 1rem;
 }
 .pagination button {
    padding: .3rem .6rem;
    font-size: .9rem;
    border: 1px solid #ccc;
    background: #fff;
    cursor: pointer;
 }
 .pagination button:disabled {
    opacity: .5;
    cursor: default;
 }
 .pagination button.active {
    background-color: #000;
    color: white;
    border-color: #000;
    font-weight: bold;
 }
 
 /* ==========================================================================
    7. ポップアップ・モーダル
    ========================================================================== */

 /* モーダルの背景 */
 .overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
    z-index: 1999;
    display: flex;
    align-items: center;
    justify-content: center;
 }
 .overlay.hidden {
    display: none;
 }

 /* モーダルの本体 */
 .modal {
    width: 90%;
    max-width: 600px;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    display: flex;
    flex-direction: column;
    max-height: 80vh;
 }
 .modal-header {
    font-weight: bold;
    padding: 1rem;
    border-bottom: 1px solid #ddd;
 }
 .modal-body {
    flex: 1;
    overflow-y: auto;
    padding: 1rem;
 }
 .modal-footer {
    display: flex;
    justify-content: flex-end;
    gap: 0.75rem;
    padding: .75rem;
    background: #f7f7f7;
    border-top: 1px solid #ddd;
 }
 .modal-footer button {
    padding: 0.6rem 1.2rem;
    font-size: 0.9rem;
    font-weight: 600;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    transition: opacity 0.2s ease;
 }
 .modal-footer button:hover {
    opacity: 0.85;
 }
 
 /* 個別のモーダルボタンの色 */
 #modal-close-btn, #tag-panel-reset {
    background-color: #6c757d;
    color: white;
 }
 #tag-panel-confirm {
    background-color: #ff9800;
    color: white;
 }

 /* タグ絞り込みモーダルの特別スタイル */
 .tag-panel .modal-body { padding: 0; }
 .tag-panel .tag-search-input { width: 100%; padding: .75rem; font-size: 1rem; border: none; border-bottom: 1px solid #ddd; }
 .tag-panel .category-tabs { display: flex; flex-wrap: wrap; gap: .5rem; padding: .75rem; border-bottom: 1px solid #ddd; background: #f7f7f7; }
 .tag-panel .category-tabs button { padding: .4rem .8rem; font-size: .8rem; border: 1px solid #ccc; border-radius: 1rem; background: #fff; cursor: pointer; }
 .tag-panel .category-tabs button.active { background: #333; color: #fff; border-color: #333; }
 .tag-panel .tag-list { padding: .75rem; display: grid; height: 30vh; overflow-y: auto; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: .5rem; align-content: start; }
 .tag-panel .tag-list label { display: flex; align-items: center; gap: .5rem; margin-bottom: 0; font-size: .9rem; cursor: pointer; }
 .tag-panel .tag-list input { margin: 0; }
 #filter-mode-select-buttons { display: flex; gap: 0.5rem; margin-right: auto; }
 #filter-mode-select-buttons button { padding: 0.4rem 0.8rem; font-size: 0.8rem; border-radius: 4px; background-color: #aaa; color: white; }
 #filter-mode-select-buttons button.active { background-color: #28a745; }

 /* お問い合わせフォームのスタイル */
 .contact-form .form-group { margin-bottom: 1rem; }
 .contact-form .form-group label { display: block; margin-bottom: 0.25rem; font-weight: bold; font-size: 0.9rem; }
 .contact-form .form-group input, .contact-form .form-group textarea { width: 100%; padding: 0.6rem; border: 1px solid #ccc; border-radius: 4px; font-size: 1rem; }
 .contact-form .form-group textarea { min-height: 120px; resize: vertical; }

 /* 右下に表示される通知 */
 .toast {
    position: fixed;
    bottom: 1rem;
    right: 1rem;
    background: rgba(0, 0, 0, .8);
    color: #fff;
    padding: .5rem 1rem;
    border-radius: 4px;
    opacity: 0;
    transition: opacity .3s;
    z-index: 3000;
 }
 .toast.show {
    opacity: 1;
 }
 
 /* 画像プレビューのポップアップ */
 .image-preview-popup {
    display: none;
    position: fixed;
    z-index: 4000;
    pointer-events: none;
    border: 2px solid #ccc;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    max-width: 400px;
    max-height: 90vh;
    overflow: hidden;
    border-radius: 4px;
    background-color: #fff;
    transition: opacity 0.1s;
 }
 .image-preview-popup img {
    display: block;
    width: 100%;
    height: auto;
 }
 
 /* リスト追加時のポップオーバー */
 .add-to-list-popover {
    position: absolute;
    z-index: 100;
    background-color: white;
    border: 1px solid #ccc;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    border-radius: 6px;
    padding: .75rem;
    width: 250px;
 }
 .add-to-list-popover ul { list-style: none; max-height: 150px; overflow-y: auto; margin-bottom: .75rem; }
 .add-to-list-popover li label { display: block; padding: .25rem 0; cursor: pointer; display: flex; align-items: center; gap: .5rem; }
 .add-to-list-popover .new-list-form { display: flex; gap: .5rem; border-top: 1px solid #eee; padding-top: .75rem; }
 .add-to-list-popover .new-list-form input { flex-grow: 1; padding: .4rem; border: 1px solid #ccc; border-radius: 4px; }
 .add-to-list-popover .new-list-form button { padding: 0 .8rem; background-color: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; }

 /* ==========================================================================
    8. マイリストページ
    ========================================================================== */

 #mylists-container {
    display: flex;
    gap: 1.5rem;
    align-items: flex-start;
    transition: all 0.3s ease;
 }
 .mylists-sidebar {
    flex: 0 0 300px; /* サイドバーの幅を固定 */
    transition: all 0.3s ease;
 }
 .mylists-content {
    flex-grow: 1;
    min-width: 0;
 }
 /* サイドバーが折りたたまれた時のスタイル */
 #mylists-container.sidebar-collapsed .mylists-sidebar {
    flex-basis: 0;
    width: 0;
    overflow: hidden;
    padding: 0;
    margin-left: -1.5rem;
    opacity: 0;
 }
 #toggle-sidebar-btn {
    background: none;
    border: 1px solid #ccc;
    border-radius: 4px;
    cursor: pointer;
    padding: 0.1rem 0.4rem;
    font-size: 1em;
    line-height: 1;
    color: #555;
 }
 #toggle-sidebar-btn:hover { background: #eee; }
 
 .mylists-sidebar h3, .mylists-content h3 { margin-bottom: 1rem; }
 .mylists-sidebar ul { list-style: none; }
 .mylists-sidebar li { margin-bottom: .5rem; }
 .mylists-sidebar .list-group-item {
    width: 100%;
    text-align: left;
    padding: .6rem;
    border: 1px solid #eee;
    background: #fff;
    cursor: pointer;
    border-radius: 4px;
    display: flex;
    justify-content: space-between;
    align-items: center;
 }
 .mylists-sidebar .list-group-item.active {
    background-color: #333;
    color: white;
    border-color: #333;
 }
 .list-item-controls {
    display: flex;
    gap: 0.5rem;
 }
 .list-item-controls button {
    background: none;
    border: none;
    font-size: 1rem;
    cursor: pointer;
    padding: 0 .2rem;
    opacity: 0.5;
 }
 .list-group-item:hover .list-item-controls button { opacity: 1; }
 
 /* リスト名編集フォーム */
 .list-edit-form {
    display: flex;
    width: 100%;
    gap: 0.5rem;
    padding: 0.6rem;
    border: 1px solid #ccc;
    border-radius: 4px;
 }
 .list-edit-form input { flex-grow: 1; border: 1px solid #999; padding: 0.2rem; }
 .list-edit-form button { background: none; border: none; font-size: 1rem; cursor: pointer; }
 
 /* リスト作成・インポートエリア */
 .list-actions { margin-top: 1rem; margin-bottom: 1rem; }
 .list-actions .form-group { display: flex; gap: .5rem; margin-bottom: 0.5rem; }
 .list-actions input { flex-grow: 1; padding: .5rem; }
 .list-actions button { padding: .5rem; }
 #share-id-display { user-select: all; background: #eee; padding: 0.5rem; border-radius: 4px; cursor: pointer; }
 #share-id-display:hover { background: #ddd; }

 /* ==========================================================================
    9. レスポンシブデザイン（スマホ向けスタイル）
    ========================================================================== */

 /* PC表示では改行を無効にする */
 br.mobile-only {
    display: none;
 }

 /* 画面幅が768px以下の場合に適用 */
 @media screen and (max-width: 768px) {
    body {
        font-size: 14px;
        -webkit-text-size-adjust: 100%;
    }
    .container {
        margin: 1rem auto;
        padding: 0 0.75rem;
    }
    .site-header h1 {
        font-size: 1.8rem;
    }
    br.mobile-only {
        display: inline;
    }
    .section-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.5rem;
    }
    h2 {
        font-size: 1.2rem;
    }
    hr {
        margin: 1.5rem 0;
    }

    /* ハンバーガーメニュー関連 */
    .hamburger-btn {
        display: block;
    }
    #view-main > .controls {
        display: none;
    }
    #view-favorites .filter-controls {
        display: none;
    }
    
    /* navボタンの高さ統一とハンバーガーアイコンのサイズ調整 */
    .main-nav button {
        height: 36px;
        padding-top: 0;
        padding-bottom: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.9rem;
        padding-left: 0.8rem;
        padding-right: 0.8rem;
    }
    .main-nav .hamburger-btn {
        font-size: 1.2rem;
    }

    .controls {
        flex-direction: column;
        gap: 0.75rem;
        align-items: stretch;
    }
    .controls input {
        min-width: 0;
        width: 100%;
        padding: .75rem;
        font-size: 1rem;
    }
    .controls button {
        width: 100%;
    }
    .controls:has(#dlsiteUrl) {
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
    }
    .controls:has(#dlsiteUrl) #dlsiteUrl {
        flex: 1;
    }
    .controls:has(#dlsiteUrl) #addBtn {
        flex-shrink: 0;
        width: auto;
        padding: .75rem;
    }
    .filter-controls {
        flex-direction: column;
        gap: 0.75rem;
        align-items: stretch;
    }
    .filter-controls button {
        width: 100%;
    }
    .tabs {
        position: relative;
    }
    .tab-content {
        padding: 0.75rem;
    }
    .tabs-container {
        overflow-x: auto;
        white-space: nowrap;
        -webkit-overflow-scrolling: touch;
        padding-bottom: 8px;
        border-bottom: 1px solid #ddd;
    }
    .tabs label {
        padding: .6rem 1.1rem;
        font-size: .9rem;
        margin-right: 4px;
    }
    #tab-admin_manga:checked ~ .tabs-container label[for="tab-admin_manga"],
    #tab-admin_game:checked ~ .tabs-container label[for="tab-admin_game"],
    #tab-new:checked ~ .tabs-container label[for="tab-new"],
    #tab-ranking:checked ~ .tabs-container label[for="tab-ranking"] {
        background: #fff;
        border: 1px solid #ddd;
        border-bottom: 1px solid #fff;
        position: relative;
        top: 1px;
    }
    .grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 0.75rem;
    }
    .item {
        display: flex;
        flex-direction: column;
        height: 320px;
        min-height: 320px;
    }
    .item img {
        height: 160px;
    }
    .title {
        font-size: .8rem;
        margin: 0 0 .5rem 0;
        flex-shrink: 0; 
    }
    .tags {
        flex: 1;
        overflow-y: auto; 
        line-height: 1.5; 
    }
    .item-footer {
        padding: .4rem;
        min-height: auto;
    }
    .rating-btn {
        padding: 3px 7px;
    }

    .item .card-actions {
        position: static; /* ホバーではなく常に表示 */
        opacity: 1;
        pointer-events: auto;
    }
    .item-footer {
        flex-direction: column;
        align-items: stretch;
        gap: 0.25rem;
    }
    .rating-buttons {
        justify-content: flex-start;
    }
    .card-actions {
        justify-content: flex-end;
    }
    
    .pagination {
        gap: .25rem;
    }
    .pagination button,
    .pagination span {
        font-size: 0.85rem;
    }
    .pagination button {
        padding: .4rem .6rem;
    }
    .modal {
        width: 95vw;
        max-height: 85vh;
    }
    .modal-body {
        padding: 0.75rem;
    }
    .tag-panel .tag-list {
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        height: 40vh;
        gap: .75rem;
    }
    .tag-panel .category-tabs {
        padding: 0.5rem;
        gap: 0.25rem;
    }
    .tag-panel .category-tabs button {
        font-size: 0.75rem;
    }
    .modal-footer {
        flex-direction: column;
        gap: 0.5rem;
    }
    #filter-mode-select-buttons {
        order: -1;
        width: 100%;
        justify-content: center;
        margin-right: 0;
    }
    .modal-footer button {
        width: 100%;
    }
    .toast {
        left: 1rem;
        right: 1rem;
        width: auto;
        text-align: center;
    }
    .image-preview-popup {
        display: none !important; /* スマホではプレビューを無効化 */
    }
    .main-nav {
        overflow-x: auto;
        -ms-overflow-style: none;  /* IE, Edge */
        scrollbar-width: none;  /* Firefox */
    }
    .main-nav::-webkit-scrollbar { /* Chrome, Safari */
        display: none;
    }
    #mylists-container {
        flex-direction: column;
    }
    .mylists-sidebar {
        width: 100%;
        flex-basis: auto;
        transition: max-height 0.3s ease-out;
    }
    #mylists-container.sidebar-collapsed .mylists-sidebar {
        max-height: 0;
        overflow: hidden;
        padding-top: 0;
        padding-bottom: 0;
        margin-bottom: 0;
        border: none;
    }
    #toggle-sidebar-btn {
        display: block;
    }
    /* 「リストに追加」ポップオーバーを画面中央に固定 */
    .add-to-list-popover {
        width: 90vw; /* 画面幅の90% */
        max-width: 300px; /* 最大幅は300pxに */
    }
    /* リスト追加ポップオーバー専用の背景オーバーレイ */
    .popover-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        z-index: 2000; /* 他の要素より手前に表示 */
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 1rem;
    }
 }
 </style>
</head>
<body>
    <div class="container">
        <header class="site-header">
            <h1>DLsiteのおすすめ<br class="mobile-only">教えてくれ</h1>
            <p>※当サイトはアフィリエイト広告を利用しています</p>
        </header>

        <div class="auth-area">
            <span id="userName" class="hidden"></span>
            <button id="loginBtn">Googleでログイン</button>
            <button id="logoutBtn" class="hidden">ログアウト</button>
        </div>

        <nav class="main-nav">
            <button id="hamburger-btn" class="hamburger-btn">☰</button>
            <button id="nav-home" class="active">ホーム</button>
            <button id="nav-favorites" class="requires-auth" disabled>お気に入り</button>
            <button id="nav-mylists" class="requires-auth" disabled>マイリスト</button>
        </nav>
        
        <div id="mobile-menu" class="mobile-menu hidden">
            <button data-action="contact">お問い合わせ</button>
            <button data-action="filter-tags">タグで絞り込み</button>
            <button data-action="reset-filter" class="hidden">絞り込み解除</button>
            <button data-action="toggle-bad">Bad評価を非表示</button>
            <button data-action="toggle-mosaic">モザイク ON</button>
            <button data-action="info">サイト情報</button>
        </div>

        <div id="view-main">
            <div class="controls">
                <button id="contactBtn">お問い合わせ</button>
                <button class="filterByTagsBtn">タグで絞り込み</button>
                <button class="resetFilterBtn hidden">絞り込み解除</button>
                <button id="hideBadBtn">Bad評価を非表示</button>
                <button id="mosaicToggleBtn">モザイク ON</button>
                <button id="infoBtn">サイト情報</button>
            </div>
            <hr>
            <div class="section-header collapser-header" data-section="admin">
                <h2>管理者のおすすめ</h2>
                <div class="view-options"><label for="adminPageSizeSelector">表示件数:</label><select id="adminPageSizeSelector"></select></div>
            </div>
            <div class="collapsible-content">
                <div class="tabs">
                    <input type="radio" id="tab-admin_manga" name="admin_tab" checked><input type="radio" id="tab-admin_game" name="admin_tab">
                    <div class="tabs-container"><label for="tab-admin_manga">漫画</label><label for="tab-admin_game">ゲーム</label></div>
                    <section id="admin_manga" class="tab-content">
                        <div class="grid" id="adminMangaGrid"></div>
                        <div class="pagination" id="adminMangaPagination"></div>
                    </section>
                    <section id="admin_game" class="tab-content">
                        <div class="grid" id="adminGameGrid"></div>
                        <div class="pagination" id="adminGamePagination"></div>
                    </section>
                </div>
            </div>
            <hr>
            <div class="section-header collapser-header" data-section="user">
                <h2>みんなの投稿</h2>
                <div class="view-options"><label for="userPageSizeSelector">表示件数:</label><select id="userPageSizeSelector"></select></div>
            </div>
            <div class="collapsible-content">
                <div class="controls"><input type="url" id="dlsiteUrl" placeholder="DLsite作品URLを貼り付け" required><button id="addBtn">追加</button></div>
                <div class="tabs">
                    <input type="radio" id="tab-new" name="tab" checked><input type="radio" id="tab-ranking" name="tab">
                    <div class="tabs-container"><label for="tab-new">新着</label><label for="tab-ranking">ランキング</label></div>
                    <section id="new" class="tab-content">
                        <div class="grid" id="newGrid"></div>
                        <div class="pagination" id="newPagination"></div>
                    </section>
                    <section id="ranking" class="tab-content">
                        <div class="grid" id="rankingGrid"></div>
                        <div class="pagination" id="rankingPagination"></div>
                    </section>
                </div>
            </div>
        </div>
        <div id="view-favorites" class="view-container">
            <div class="section-header">
                <h2>お気に入り</h2>
                <div class="view-options">
                    <label>表示件数:<select id="favoritesPageSizeSelector"></select></label>
                </div>
            </div>
            <div class="filter-controls">
                <button class="filterByTagsBtn">タグで絞り込み</button>
                <button class="resetFilterBtn hidden">絞り込み解除</button>
            </div>
            <div class="grid" id="favoritesGrid"></div>
            <div class="pagination" id="favoritesPagination"></div>
        </div>
        <div id="view-mylists" class="view-container">
            <div class="section-header">
                <h2>
                    マイリスト
                    <button id="toggle-sidebar-btn" title="サイドバーを開閉">◀</button>
                </h2>
            </div>
            <div id="mylists-container"></div>
        </div>
        <div id="view-public-list" class="view-container">
            <div class="section-header">
                <h2 id="public-list-name"></h2>
                <div><button id="import-public-list-btn" class="requires-auth" disabled>このリストを複製</button></div>
            </div>
            <p id="public-list-owner"></p>
            <div id="public-list-grid" class="grid"></div>
        </div>
    </div>

    <div id="modalOverlay" class="overlay hidden"><div id="modalContent" class="modal"></div></div>
    <div id="toast" class="toast"></div>
    <div id="imagePreviewPopup" class="image-preview-popup"></div>
    <div id="details-popup"></div>

    <script type="module">
        // --- モジュールのインポート ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-app.js";
        import { getDatabase, ref, onValue, push, set, remove, serverTimestamp, get, child, update } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-database.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-auth.js";
        import { getFunctions } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-functions.js";

        // --- 定数定義 ---
        const CONSTANTS = {
            DL_AFFILIATE_ID: "sukumizuyoujo",
            FIREBASE_CONFIG: {
                apiKey: "AIzaSyCjbDIVVnl_lf-vOCKSf3_hWOjCDNxaJts",
                authDomain: "dlsite-share.firebaseapp.com",
                databaseURL: "https://dlsite-share-default-rtdb.firebaseio.com",
                projectId: "dlsite-share",
                storageBucket: "dlsite-share.appspot.com",
                messagingSenderId: "764936540510",
                appId: "1:764936540510:web:846938ef579ea0b0cf3fcf",
                measurementId: "G-LXNH02PV7J"
            },
            DB_PATHS: {
                WORKS: "works", ADMIN_PICKS: "adminPicks", TAGS: "tags", CATEGORIES: "categories", CONTACTS: "contacts",
                FAVORITES: "userFavorites", USER_LISTS: "userLists", LISTS: "lists", LIST_ITEMS: "listItems"
            },
            PAGE_SIZE_OPTIONS: {
                mobile: { admin: [8, 10, 12], user: [10, 20, 30], favorites: [10, 20, 30] },
                pc: { admin: [5, 10, 15], user: [10, 20, 40], favorites: [10, 20, 40] }
            },
            LIST_LIMITS: { MAX_LISTS: 10, MAX_ITEMS_PER_LIST: 100 }
        };

        // --- 状態管理 ---
        const state = {
            works: {}, adminPicks: {}, tags: {}, tagNameToDataMap: new Map(), categories: {},
            sortedWorkIds: { new: [], ranking: [], favorites: [] },
            sortedAdminIds: { manga: [], game: [] },
            currentPage: { new: 1, ranking: 1, admin_manga: 1, admin_game: 1, favorites: 1 },
            pageSize: { admin: 10, user: 40, favorites: 40 },
            sectionsCollapsed: { admin: false, user: false },
            clientId: null, hideBadlyRated: false, mosaicActive: false,
            highlightTagIds: new Set(), hideTagIds: new Set(), currentTagEditMode: 'highlight',
            currentUser: null, favorites: new Set(), myLists: {}, myListItems: {}, activeListId: null, currentView: 'main',
            isInitialDataLoaded: { works: false, adminPicks: false }
        };

        // --- DOM要素のキャッシュ ---
        const dom = {
            container: document.querySelector('.container'),
            urlInput: document.getElementById("dlsiteUrl"),
            authArea: document.querySelector('.auth-area'), userName: document.getElementById('userName'),
            loginBtn: document.getElementById('loginBtn'), logoutBtn: document.getElementById('logoutBtn'),
            nav: { home: document.getElementById('nav-home'), favorites: document.getElementById('nav-favorites'), mylists: document.getElementById('nav-mylists') },
            views: { main: document.getElementById('view-main'), favorites: document.getElementById('view-favorites'), mylists: document.getElementById('view-mylists'), publicList: document.getElementById('view-public-list') },
            grids: {
                new: document.getElementById("newGrid"), ranking: document.getElementById("rankingGrid"),
                admin_manga: document.getElementById("adminMangaGrid"), admin_game: document.getElementById("adminGameGrid"),
                favorites: document.getElementById('favoritesGrid'), publicList: document.getElementById('public-list-grid')
            },
            pageSizeSelectors: {
                admin: document.getElementById('adminPageSizeSelector'), user: document.getElementById('userPageSizeSelector'),
                favorites: document.getElementById('favoritesPageSizeSelector')
            },
            mylistsContainer: document.getElementById('mylists-container'),
            publicListName: document.getElementById('public-list-name'), publicListOwner: document.getElementById('public-list-owner'),
            importPublicListBtn: document.getElementById('import-public-list-btn'),
            toast: document.getElementById("toast"), modalOverlay: document.getElementById("modalOverlay"), modalContent: document.getElementById("modalContent"),
            imagePreviewPopup: document.getElementById("imagePreviewPopup"),
            hamburgerBtn: document.getElementById('hamburger-btn'),
            mobileMenu: document.getElementById('mobile-menu')
        };

        // --- ユーティリティ ---
        const util = {
            showToast: (msg, duration = 3000) => { dom.toast.textContent = msg; dom.toast.classList.add("show"); setTimeout(() => dom.toast.classList.remove("show"), duration); },
            getClientId: () => { let id = localStorage.getItem("clientId"); if (!id) { id = crypto.randomUUID(); localStorage.setItem("clientId", id); } return id; },
            calculateTotalPages: (totalItems, pageSize) => Math.max(1, Math.ceil(totalItems / pageSize)),
            classifyWork: (work) => { if (!work) return 'unknown'; if (work.manualGenre) return work.manualGenre; if (work.workType) { const type = work.workType; if (type === 'Book' || type === 'Comic') return 'manga'; if (type === 'VideoGame') return 'game'; } const url = work.pageUrl || ''; if (url.includes('/comic/') || url.includes('/books/')) return 'manga'; if (url.includes('/soft/') || url.includes('/pro/')) return 'game'; return 'unknown'; },
            hasAnyOfTags: (work, tagIdsSet) => { if (!work || !work.tags || tagIdsSet.size === 0) return false; for (const tagId of tagIdsSet) { if (work.tags[tagId]) return true; } return false; },
            escapeHTML: (str) => str ? str.replace(/[&<>"']/g, match => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[match])) : '',
        };

        // --- Firebase 初期化 ---
        const firebaseApp = initializeApp(CONSTANTS.FIREBASE_CONFIG);
        const db = getDatabase(firebaseApp);
        const auth = getAuth(firebaseApp);
        const functions = getFunctions(firebaseApp, "asia-northeast1");
        let activePopover = null;

        // --- UI描画関連 ---
        function makeCard(workId, context = '') {
            const data = state.works[workId] || state.adminPicks[workId] || Object.values(state.adminPicks).find(p => p.pageUrl.includes(workId));
            if (!data) return document.createElement('div');
            
            const canonicalWorkId = data.pageUrl?.match(/(RJ|VJ|BJ)\d{6,}/i)?.[0].toUpperCase() || workId;
            const { title, coverUrl, tags = {}, votes = {}, score = 0 } = data;
            const userVote = votes[state.clientId] || 0;
            const isFavorited = state.favorites.has(canonicalWorkId);
            const isInAnyList = Object.keys(state.myListItems).some(listId => state.myListItems[listId]?.[canonicalWorkId]);
            const authDisabled = state.currentUser ? '' : 'disabled';
            
            const card = document.createElement("article");
            card.className = `item`;
            card.dataset.id = workId;
            card.dataset.canonicalId = canonicalWorkId;

            let cardActionsHTML = `
                <button class="favorite-btn card-action-btn ${isFavorited ? 'favorited' : ''}" title="お気に入り" ${authDisabled}>♥</button>
                <button class="add-to-list-btn card-action-btn ${isInAnyList ? 'in-list' : ''}" title="リストに追加" ${authDisabled}>+</button>
            `;
            if (context === 'myList' && state.activeListId) {
                cardActionsHTML += `<button class="remove-from-list-btn card-action-btn" title="リストから削除" data-list-id="${state.activeListId}">×</button>`;
            }

            let footerHTML = `
                <div class="rating-buttons">
                    <button class="rating-btn good" data-score="1">Good</button>
                    <button class="rating-btn bad" data-score="-1">Bad</button>
                    <span class="score-display">${score}</span>
                </div>
                <div class="card-actions">${cardActionsHTML}</div>`;
            
            if (['favorites', 'admin', 'myList', 'publicList'].includes(context)) {
                footerHTML = `<div class="card-actions">${cardActionsHTML}</div>`;
            }
            
            card.innerHTML = `<img src="${coverUrl}" alt="${title}" loading="lazy"> <div class="item-body"> <h3 class="title">${util.escapeHTML(title)}</h3> <div class="tags">${Object.values(tags).map(n => `<span class="tag">${util.escapeHTML(n)}</span>`).join("")}</div> </div> <div class="item-footer">${footerHTML}</div>`;
            
            // 状態に応じてactiveクラスを付与
            const goodBtn = card.querySelector('.rating-btn.good');
            const badBtn = card.querySelector('.rating-btn.bad');
            if (userVote === 1 && goodBtn) goodBtn.classList.add('active');
            if (userVote === -1 && badBtn) badBtn.classList.add('active');

            return card;
        }

        function createSkeletonCard() {
            const card = document.createElement("div");
            card.className = "skeleton-card";
            return card;
        }

        function renderSkeletons(gridElement, count) {
            if(!gridElement) return;
            gridElement.innerHTML = "";
            for (let i = 0; i < count; i++) {
                gridElement.appendChild(createSkeletonCard());
            }
        }

        function adjustPcGridHeight(gridElement, pageSize) {
            if (window.innerWidth <= 768 || !gridElement) { if (gridElement) gridElement.style.minHeight = 'auto'; return; }
            requestAnimationFrame(() => {
                const gridComputedStyle = window.getComputedStyle(gridElement);
                const columnCount = gridComputedStyle.gridTemplateColumns.split(' ').length;
                if (columnCount > 0) {
                    const cardHeight = 320;
                    const rowGap = parseInt(gridComputedStyle.gap, 10) || 16;
                    const rowCount = Math.ceil(pageSize / columnCount);
                    const minHeight = rowCount * cardHeight + (rowCount > 0 ? (rowCount - 1) * rowGap : 0);
                    gridElement.style.minHeight = `${minHeight}px`;
                }
            });
        }
        
        function getFilteredIdsForView(type) {
            const isAdmin = type.startsWith('admin_');
            const isFav = type === 'favorites';
            
            let baseIds = [];
            let sourceData = state.works;

            if (isAdmin) {
                const genre = type.split('_')[1];
                baseIds = state.sortedAdminIds[genre] || [];
                sourceData = state.adminPicks;
            } else if (isFav) {
                baseIds = state.sortedWorkIds.favorites || [];
                sourceData = { ...state.works, ...state.adminPicks };
            } else {
                baseIds = state.sortedWorkIds[type] || [];
            }
            
            let filteredIds = [...baseIds];

            if (state.hideBadlyRated && !isAdmin && !isFav) {
                filteredIds = filteredIds.filter(id => (sourceData[id]?.votes?.[state.clientId] || 0) !== -1);
            }

            if (!isAdmin && (state.highlightTagIds.size > 0 || state.hideTagIds.size > 0)) {
                const hasHideTag = id => util.hasAnyOfTags(sourceData[id], state.hideTagIds);
                const hasHighlightTag = id => util.hasAnyOfTags(sourceData[id], state.highlightTagIds);

                const nonHidden = filteredIds.filter(id => !hasHideTag(id));
                if (state.highlightTagIds.size > 0) {
                    const highlighted = nonHidden.filter(hasHighlightTag);
                    const others = nonHidden.filter(id => !hasHighlightTag(id));
                    return [...highlighted, ...others];
                }
                return nonHidden;
            }
            return filteredIds;
        }

        function renderPage(type) {
            const grid = dom.grids[type];
            if (!grid) return;

            const isFav = type === 'favorites';
            const isAdmin = type.startsWith('admin_');
            
            const pageSize = isAdmin ? state.pageSize.admin : (isFav ? state.pageSize.favorites : state.pageSize.user);
            const context = isAdmin ? 'admin' : (isFav ? 'favorites' : 'user');
            
            const allFilteredIds = getFilteredIdsForView(type);
            
            const totalPages = util.calculateTotalPages(allFilteredIds.length, pageSize);
            let currentPage = state.currentPage[type];
            if (currentPage > totalPages) {
                currentPage = state.currentPage[type] = totalPages;
            }
            
            const startIndex = (currentPage - 1) * pageSize;
            const endIndex = startIndex + pageSize;
            const pageIds = allFilteredIds.slice(startIndex, endIndex);

            grid.innerHTML = "";
            pageIds.forEach(id => {
                grid.appendChild(makeCard(id, context));
            });
            
            adjustPcGridHeight(grid, pageSize);

            const paginationContainerId = {
                admin_manga: 'adminMangaPagination',
                admin_game: 'adminGamePagination',
                new: 'newPagination',
                ranking: 'rankingPagination',
                favorites: 'favoritesPagination'
            }[type];

            if (paginationContainerId) {
                renderPaginationButtons(paginationContainerId, currentPage, totalPages, type);
            }
            
            const viewContainer = grid.closest('.view-container') || dom.views.main;
            const filterBtn = viewContainer.querySelector('.filterByTagsBtn');
            const resetBtn = viewContainer.querySelector('.resetFilterBtn');
            const mobileResetBtn = dom.mobileMenu.querySelector('[data-action="reset-filter"]');
            if(filterBtn && resetBtn) {
                const activeFiltersCount = state.highlightTagIds.size + state.hideTagIds.size;
                if (activeFiltersCount > 0) {
                    filterBtn.classList.add('active');
                    filterBtn.textContent = `タグ絞り込み (${state.highlightTagIds.size}優先 / ${state.hideTagIds.size}非表示)`;
                    resetBtn.classList.remove('hidden');
                    mobileResetBtn.classList.remove('hidden');
                } else {
                    filterBtn.classList.remove('active');
                    filterBtn.textContent = 'タグで絞り込み';
                    resetBtn.classList.add('hidden');
                    mobileResetBtn.classList.add('hidden');
                }
            }
        }


        function renderPaginationButtons(containerId, currentPage, totalPages, viewType) {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';
            if (totalPages <= 1) return;
            
            container.dataset.viewType = viewType;

            const createButton = (text, page, isDisabled = false, isCurrent = false) => {
                const btn = document.createElement('button');
                btn.textContent = text;
                btn.dataset.page = page;
                if (isDisabled) btn.disabled = true;
                if (isCurrent) btn.classList.add('active');
                return btn;
            };
            
            container.appendChild(createButton('<<', 1, currentPage === 1));
            container.appendChild(createButton('<', currentPage - 1, currentPage === 1));

            let startPage, endPage;
            if (totalPages <= 5) {
                startPage = 1;
                endPage = totalPages;
            } else if (currentPage <= 3) {
                startPage = 1;
                endPage = 5;
            } else if (currentPage > totalPages - 3) {
                startPage = totalPages - 4;
                endPage = totalPages;
            } else {
                startPage = currentPage - 2;
                endPage = currentPage + 2;
            }

            for (let i = startPage; i <= endPage; i++) {
                container.appendChild(createButton(i, i, false, i === currentPage));
            }

            container.appendChild(createButton('>', currentPage + 1, currentPage === totalPages));
            container.appendChild(createButton('>>', totalPages, currentPage === totalPages));
        }
        
        function openTagFilterModal() {
            dom.modalOverlay.classList.remove("hidden");
            const modal = dom.modalContent;
            modal.className = 'modal tag-panel';
            let currentHighlightTagIds = new Set(state.highlightTagIds);
            let currentHideTagIds = new Set(state.hideTagIds);
            modal.innerHTML = `<div class="modal-header">タグで絞り込み</div> <div class="modal-body"> <input type="search" class="tag-search-input" placeholder="お探しのジャンルはなんですか？"> <div class="category-tabs"></div> <div class="tag-list"></div> </div> <div class="modal-footer"> <div id="filter-mode-select-buttons"> <button data-mode="highlight">優先表示タグを選択</button> <button data-mode="hide">非表示タグを選択</button> </div> <button id="tag-panel-reset">現在のリストをリセット</button> <button id="tag-panel-confirm">適用</button> </div>`;
            const searchInput = modal.querySelector('.tag-search-input');
            const categoryTabsContainer = modal.querySelector('.category-tabs');
            const tagListContainer = modal.querySelector('.tag-list');
            const modeSelectButtons = modal.querySelector('#filter-mode-select-buttons');
            let activeCategoryId = Object.keys(state.categories)[0] || '';
            let currentEditingTagSet = state.currentTagEditMode === 'highlight' ? currentHighlightTagIds : currentHideTagIds;
            const updateModeButtons = () => { modeSelectButtons.querySelectorAll('button').forEach(btn => { btn.classList.toggle('active', btn.dataset.mode === state.currentTagEditMode); }); };
            const renderTagList = () => {
                tagListContainer.innerHTML = '';
                Object.entries(state.tags)
                    .filter(([, tag]) => tag.category === activeCategoryId && tag.name.toLowerCase().includes(searchInput.value.toLowerCase()))
                    .forEach(([tagId, tag]) => {
                        const label = document.createElement('label'); const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox'; checkbox.value = tagId;
                        checkbox.checked = currentEditingTagSet.has(tagId);
                        checkbox.onchange = () => { checkbox.checked ? currentEditingTagSet.add(tagId) : currentEditingTagSet.delete(tagId); };
                        label.appendChild(checkbox); label.append(` ${tag.name}`);
                        tagListContainer.appendChild(label);
                    });
            };
            const renderCategoryTabs = () => {
                categoryTabsContainer.innerHTML = '';
                Object.entries(state.categories).forEach(([catId, category]) => {
                    const btn = document.createElement('button'); btn.textContent = category.name; btn.className = catId === activeCategoryId ? 'active' : '';
                    btn.onclick = () => { activeCategoryId = catId; renderCategoryTabs(); renderTagList(); };
                    categoryTabsContainer.appendChild(btn);
                });
            };
            modeSelectButtons.querySelectorAll('button').forEach(btn => {
                btn.addEventListener('click', () => {
                    state.currentTagEditMode = btn.dataset.mode;
                    currentEditingTagSet = state.currentTagEditMode === 'highlight' ? currentHighlightTagIds : currentHideTagIds;
                    updateModeButtons(); renderTagList();
                });
            });
            searchInput.oninput = renderTagList;
            modal.querySelector('#tag-panel-reset').onclick = () => { currentEditingTagSet.clear(); renderTagList(); };
            modal.querySelector('#tag-panel-confirm').onclick = () => {
                state.highlightTagIds = new Set(currentHighlightTagIds); state.hideTagIds = new Set(currentHideTagIds);
                refreshAllGrids(); dom.modalOverlay.classList.add("hidden");
            };
            updateModeButtons(); renderCategoryTabs(); renderTagList();
        }
        
        function openContactModal() {
            dom.modalOverlay.classList.remove("hidden");
            const modal = dom.modalContent;
            modal.className = 'modal contact-form';
            modal.innerHTML = `<div class="modal-header">お問い合わせ</div> <form id="contactForm" class="modal-body"> <div class="form-group"> <label for="contactName">お名前<span style="color:red">*</span></label> <input type="text" id="contactName" placeholder="名前またはニックネーム" required> </div> <div class="form-group"> <label for="contactEmail">メール<span style="color:red">*</span></label> <input type="email" id="contactEmail" placeholder="例: info@example.com" required> </div> <div class="form-group"> <label for="contactTitle">タイトル</label> <input type="text" id="contactTitle"> </div> <div class="form-group"> <label for="contactContent">お問い合わせ内容<span style="color:red">*</span></label> <textarea id="contactContent" placeholder="コメントまたはメッセージ" required></textarea> </div> </form> <div class="modal-footer"> <button id="modal-close-btn">閉じる</button> <button id="contact-submit-btn" type="submit" form="contactForm" style="background-color: #28a745; color: white;">送信</button> </div>`;
            modal.querySelector('#modal-close-btn').onclick = () => dom.modalOverlay.classList.add("hidden");
            modal.querySelector('#contactForm').onsubmit = handleContactSubmit;
        }

        function openInfoModal() {
            dom.modalOverlay.classList.remove("hidden");
            const modal = dom.modalContent;
            modal.className = 'modal info-panel';
            modal.innerHTML = `
                <div class="modal-header">このサイトについて</div>
                <div class="modal-body">
                    <p>DLsiteのおすすめ作品を、みんなで気軽に共有・評価できる非公式ファンサイトです。 気になる作品を投稿したり、ユーザーのレビューを参考にしたり、自分だけのコレクションを作って楽しもう！</p>
                    <hr>
                    <h3 style="margin-top: 1rem; margin-bottom: 0.5rem;">⚠️ 注意事項</h3>
                    <ul style="list-style-position: inside; padding-left: 0.5rem; font-size: 0.9rem; line-height: 1.6;">
                        <li>当サイトは個人により運営されております。予告なくサービスの停止、または掲載データの変更・削除を行う場合がございますので、あらかじめご了承ください。</li>
                        <li>掲載されているコンテンツ（文章・画像・作品情報等）の著作権は、各権利者に帰属します。内容に問題がある場合は、「お問い合わせ」よりご連絡ください。</li>
                        <li>DLsiteのページ構造は作品ごとに異なるため、一部の作品ではタグが自動で追加されない場合がございます。</li>
                        <li>自動でタグが追加されない作品につきましては、数日おきに手動で更新を行っております。反映までお時間をいただく場合がございますが、何卒ご理解賜りますようお願い申し上げます。</li>
                        <li>当サイト内の一部リンクには、アフィリエイトプログラムを利用しているものが含まれております。</li>
                    </ul>
                </div>
                <div class="modal-footer">
                    <button id="modal-close-btn">閉じる</button>
                </div>`;
            modal.querySelector('#modal-close-btn').onclick = () => dom.modalOverlay.classList.add("hidden");
        }
        
        function openAddToListPopover(workId, button) {
            if (activePopover) activePopover.remove();
            
            const isMobile = window.innerWidth <= 768;
            const popover = document.createElement('div');
            popover.className = 'add-to-list-popover';
            
            let listHtml = '<ul>';
            if (Object.keys(state.myLists).length > 0) {
                for (const listId in state.myLists) {
                    const list = state.myLists[listId];
                    const isChecked = state.myListItems[listId]?.[workId] ? 'checked' : '';
                    listHtml += `<li><label><input type="checkbox" data-list-id="${listId}" ${isChecked}> ${util.escapeHTML(list.name)}</label></li>`;
                }
            } else {
                listHtml += '<li>リストがありません</li>';
            }
            listHtml += '</ul>';
            popover.innerHTML = `${listHtml} <form class="new-list-form"><input type="text" placeholder="新規リスト名" required><button type="submit">+</button></form>`;

            popover.addEventListener('click', e => e.stopPropagation());
            
            if (isMobile) {
                const overlay = document.createElement('div');
                overlay.className = 'popover-overlay';
                overlay.appendChild(popover);
                document.body.appendChild(overlay);
                activePopover = overlay;
                overlay.addEventListener('click', () => { if (activePopover) { activePopover.remove(); activePopover = null; } }, { once: true });
            } else {
                document.body.appendChild(popover);
                activePopover = popover;
                const btnRect = button.getBoundingClientRect();
                const popoverRect = popover.getBoundingClientRect();
                let top = window.scrollY + btnRect.bottom + 5;
                let left = window.scrollX + btnRect.right - popoverRect.width;
                if (left < 0) { left = window.scrollX + btnRect.left; }
                if (top + popoverRect.height > window.innerHeight + window.scrollY) { top = window.scrollY + btnRect.top - popoverRect.height - 5; }
                popover.style.left = `${left}px`;
                popover.style.top = `${top}px`;
                setTimeout(() => document.addEventListener('click', () => { if (activePopover && !activePopover.classList.contains('popover-overlay')) { activePopover.remove(); activePopover = null; } }, { once: true }), 0);
            }
            
            popover.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.addEventListener('change', () => toggleWorkInList(workId, cb.dataset.listId, cb.checked)));
            popover.querySelector('form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const input = e.target.querySelector('input');
                const newListId = await createNewList(input.value);
                if (newListId) await toggleWorkInList(workId, newListId, true);
                if (activePopover) { activePopover.remove(); activePopover = null; }
            });
        }
        
        async function renderMyListsPage() {
            dom.mylistsContainer.innerHTML = `<div class="mylists-sidebar"><h3>マイリスト一覧 (${Object.keys(state.myLists).length}/${CONSTANTS.LIST_LIMITS.MAX_LISTS})</h3><ul id="mylists-sidebar-list"></ul><div class="list-actions"><div class="form-group"><input type="text" id="new-list-name-main" placeholder="新規リスト名"><button id="create-list-btn-main">作成</button></div></div><hr><h3>リストをインポート</h3><div class="list-actions"><div class="form-group"><input type="text" id="import-list-id" placeholder="共有ID"><button id="import-list-btn">追加</button></div></div></div><div class="mylists-content"><h3 id="current-list-name">リストを選択してください</h3><div class="list-actions" id="current-list-actions" style="display:none;"><p>共有ID: <span id="share-id-display"></span></p></div><div id="current-list-grid" class="grid"></div></div>`;
            const listUl = dom.mylistsContainer.querySelector('#mylists-sidebar-list');
            listUl.innerHTML = '';
            Object.values(state.myLists).sort((a, b) => a.createdAt - b.createdAt).forEach(list => {
                const li = document.createElement('li');
                li.dataset.listId = list.id;
                li.innerHTML = `<div class="list-group-item ${list.id === state.activeListId ? 'active' : ''}"><span class="list-name-text">${util.escapeHTML(list.name)}</span><div class="list-item-controls"><button class="edit-list-btn" title="リスト名を編集">✏️</button><button class="delete-list-btn" title="リストを削除">🗑️</button></div></div>`;
                listUl.appendChild(li);
            });
            listUl.onclick = (e) => {
                const target = e.target;
                const li = target.closest('li[data-list-id]');
                if (!li) return;
                const listId = li.dataset.listId;
                if (target.closest('.edit-list-btn')) {
                    e.stopPropagation();
                    const currentName = state.myLists[listId].name;
                    li.innerHTML = `<div class="list-edit-form"><input type="text" value="${util.escapeHTML(currentName)}"><button class="save-list-btn">✔️</button><button class="cancel-edit-btn">❌</button></div>`;
                    li.querySelector('input').focus();
                } else if (target.closest('.delete-list-btn')) {
                    e.stopPropagation();
                    deleteList(listId);
                } else if (target.closest('.save-list-btn')) {
                    e.stopPropagation();
                    const newName = li.querySelector('input').value.trim();
                    if (newName && newName !== state.myLists[listId].name) { renameList(listId, newName); } else { renderMyListsPage(); }
                } else if (target.closest('.cancel-edit-btn')) {
                    e.stopPropagation();
                    renderMyListsPage();
                } else if (state.activeListId !== listId) {
                    state.activeListId = listId;
                    renderMyListsPage();
                }
            };
            dom.mylistsContainer.querySelector('#create-list-btn-main').onclick = () => { const input = dom.mylistsContainer.querySelector('#new-list-name-main'); if (input.value) createNewList(input.value).then(() => { input.value = ''; }); };
            dom.mylistsContainer.querySelector('#import-list-btn').onclick = () => { const input = dom.mylistsContainer.querySelector('#import-list-id'); if (input.value) importList(input.value.trim()).then(() => { input.value = ''; }); };
            
            if (state.activeListId && state.myLists[state.activeListId]) {
                const list = state.myLists[state.activeListId];
                const listItems = state.myListItems[state.activeListId] || {};
                const itemIds = Object.keys(listItems).sort((a, b) => listItems[b].addedAt - listItems[a].addedAt);
                
                dom.mylistsContainer.querySelector('#current-list-name').textContent = util.escapeHTML(list.name);
                const grid = dom.mylistsContainer.querySelector('#current-list-grid');
                renderSkeletons(grid, itemIds.length || 10);
                
                const neededWorkIds = itemIds.filter(id => !state.works[id] && !state.adminPicks[id]);
                if (neededWorkIds.length > 0) {
                    const workPromises = neededWorkIds.map(workId =>
                        get(child(ref(db), `${CONSTANTS.DB_PATHS.WORKS}/${workId}`)).then(snap => {
                            if (snap.exists()) {
                                state.works[snap.key] = { id: snap.key, ...snap.val() };
                            }
                        })
                    );
                    await Promise.all(workPromises);
                }
                
                grid.innerHTML = '';
                itemIds.forEach(workId => {
                    if (state.works[workId] || state.adminPicks[workId]) {
                        grid.appendChild(makeCard(workId, 'myList'));
                    }
                });
                const actions = dom.mylistsContainer.querySelector('#current-list-actions');
                actions.style.display = 'block';
                const shareIdSpan = actions.querySelector('#share-id-display');
                shareIdSpan.textContent = list.id;
                shareIdSpan.onclick = () => {
                    navigator.clipboard.writeText(list.id).then(() => util.showToast('IDをコピーしました！'), () => util.showToast('コピーに失敗しました'));
                };
            }
        }
        
        function renderPublicListPage({ info, items, works }) {
            showView('publicList');
            dom.publicListName.textContent = util.escapeHTML(info.name);
            dom.publicListOwner.textContent = `作成者: ${util.escapeHTML(info.ownerName || '匿名')}`;
            dom.importPublicListBtn.dataset.listId = info.id;
            const grid = dom.grids.publicList;
            grid.innerHTML = '';

            const allAvailableWorks = { ...state.works, ...state.adminPicks, ...works };
            const sortedItems = Object.entries(items).sort((a, b) => b[1].addedAt - a[1].addedAt);
            
            sortedItems.forEach(([workId]) => {
                if (allAvailableWorks[workId]) {
                        grid.appendChild(makeCard(workId, 'publicList'));
                }
            });
        }
        
        function showView(viewName) {
            state.currentView = viewName;
            Object.keys(dom.views).forEach(key => { dom.views[key].style.display = key === viewName ? 'block' : 'none'; });
            Object.keys(dom.nav).forEach(key => {
                const viewForNav = key === 'home' ? 'main' : (key === 'mylists' ? 'mylists' : key);
                dom.nav[key].classList.toggle('active', viewForNav === viewName || (viewForNav === 'main' && viewName === 'publicList'));
            });
            const url = new URL(window.location);
            if (viewName === 'publicList') { /* URL is already set */ }
            else if (viewName !== 'main') { url.searchParams.set('view', viewName); url.searchParams.delete('list'); history.pushState({ view: viewName }, '', url); }
            else { url.searchParams.delete('view'); url.searchParams.delete('list'); history.pushState({ view: 'main' }, '', url); }
            
            if (viewName === 'favorites') {
                if(!state.isInitialDataLoaded.works) renderSkeletons(dom.grids.favorites, state.pageSize.favorites);
                renderPage('favorites');
            }
            if (viewName === 'mylists') renderMyListsPage();
        }
        
        // --- データベース操作 & ロジック ---
        async function handleContactSubmit(event) {
            event.preventDefault();
            const btn = document.getElementById('contact-submit-btn');
            const name = document.getElementById('contactName').value.trim();
            const email = document.getElementById('contactEmail').value.trim();
            const title = document.getElementById('contactTitle').value.trim();
            const content = document.getElementById('contactContent').value.trim();
            if (!name || !email || !content) { return util.showToast("必須項目をすべて入力してください"); }
            btn.disabled = true; btn.textContent = '送信中...';
            const contactData = { name, email, title, content, timestamp: serverTimestamp(), isRead: false };
            try { await push(ref(db, CONSTANTS.DB_PATHS.CONTACTS), contactData); util.showToast("お問い合わせを送信しました。"); dom.modalOverlay.classList.add("hidden"); }
            catch (error) { util.showToast(`送信に失敗しました: ${error.message}`); btn.disabled = false; btn.textContent = '送信'; }
        }
        
        async function addWork(url) {
            const originalUrl = url.trim();
            if (!originalUrl.includes("dlsite.com")) {
                return util.showToast("有効なDLsiteのURLを入力してください");
            }

            const functionUrl = "https://addworkfromurl-vubh7ebq4a-uc.a.run.app"; 

            const btn = document.getElementById('addBtn');
            const input = dom.urlInput;
            btn.disabled = true;
            btn.classList.add('loading');

            try {
                const response = await fetch(functionUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ data: { url: originalUrl } }),
                });

                const result = await response.json();
                
                if (!response.ok) {
                    throw new Error(result.error || '不明なエラーが発生しました。');
                }

                util.showToast(result.data.message);
                input.value = "";
            } catch (error) {
                util.showToast(`エラー: ${error.message}`);
                console.error(error);
            } finally {
                btn.disabled = false;
                btn.classList.remove('loading');
            }
        }
        
        async function handleVote(workId) {
            const data = state.works[workId] || state.adminPicks[workId];
            if(!data) return;
            
            const card = document.querySelector(`.item[data-id="${workId}"]`);
            if(!card) return;

            const goodBtn = card.querySelector('.rating-btn.good');
            const badBtn = card.querySelector('.rating-btn.bad');
            
            const score = Number(event.target.dataset.score);
            const currentVote = data.votes?.[state.clientId] || 0;
            const newVote = currentVote === score ? 0 : score;

            // Optimistic UI update
            goodBtn.classList.toggle('active', newVote === 1);
            badBtn.classList.toggle('active', newVote === -1);
            
            const workPath = state.works[workId] ? CONSTANTS.DB_PATHS.WORKS : CONSTANTS.DB_PATHS.ADMIN_PICKS;
            const voteRef = ref(db, `${workPath}/${workId}/votes/${state.clientId}`);
            try { await (newVote === 0 ? remove(voteRef) : set(voteRef, newVote)); }
            catch (error) { 
                util.showToast(`投票エラー: ${error.message}`);
                // Revert UI on error
                goodBtn.classList.toggle('active', currentVote === 1);
                badBtn.classList.toggle('active', currentVote === -1);
            }
        }
        
        async function deleteList(listId) {
            if (!state.currentUser) return;
            const listName = state.myLists[listId]?.name || 'このリスト';
            if (!confirm(`「${util.escapeHTML(listName)}」を完全に削除しますか？この操作は取り消せません。`)) return;
            const updates = {};
            updates[`${CONSTANTS.DB_PATHS.LISTS}/${listId}`] = null;
            updates[`${CONSTANTS.DB_PATHS.LIST_ITEMS}/${listId}`] = null;
            updates[`${CONSTANTS.DB_PATHS.USER_LISTS}/${state.currentUser.uid}/${listId}`] = null;
            try {
                await update(ref(db), updates);
                util.showToast('リストを削除しました。');
                if(state.activeListId === listId) { state.activeListId = null; }
            } catch (error) { util.showToast(`削除エラー: ${error.message}`); }
        }
        
        async function renameList(listId, newName) {
            if (!state.currentUser || !newName) return;
            const listRef = ref(db, `${CONSTANTS.DB_PATHS.LISTS}/${listId}/name`);
            try { await set(listRef, newName); util.showToast("リスト名を変更しました。");
            } catch (error) { util.showToast(`エラー: ${error.message}`); }
        }
        
        async function removeWorkFromList(workId, listId) {
            if (!state.currentUser) return;
            const itemRef = ref(db, `${CONSTANTS.DB_PATHS.LIST_ITEMS}/${listId}/${workId}`);
            try { await remove(itemRef); util.showToast("リストから作品を削除しました。");
            } catch (error) { util.showToast(`削除エラー: ${error.message}`); }
        }
        
        let userListeners = [];
        function subscribeUserData(user) {
            unsubscribeUserData();
            if (!user) return;
            const uid = user.uid;
            
            const favListener = onValue(ref(db, `${CONSTANTS.DB_PATHS.FAVORITES}/${uid}`), snapshot => {
                state.favorites.clear();
                if (snapshot.exists()) { Object.keys(snapshot.val()).forEach(workId => state.favorites.add(workId)); }
                updateSortedArrays();
                refreshAllGrids();
            });
            userListeners.push(favListener);

            const listMetaListener = onValue(ref(db, `${CONSTANTS.DB_PATHS.USER_LISTS}/${uid}`), async snapshot => {
                const oldListIds = Object.keys(state.myLists);
                const newListIds = snapshot.exists() ? Object.keys(snapshot.val()) : [];
                
                const removedListIds = oldListIds.filter(id => !newListIds.includes(id));
                removedListIds.forEach(id => {
                    delete state.myLists[id];
                    delete state.myListItems[id];
                });

                const listPromises = newListIds.map(id => get(child(ref(db), `${CONSTANTS.DB_PATHS.LISTS}/${id}`)).then(s => s.exists() ? { id: s.key, ...s.val() } : null));
                const lists = (await Promise.all(listPromises)).filter(Boolean);
                
                let needsRender = false;
                for (const l of lists) {
                    const needsListener = !state.myLists[l.id];
                    state.myLists[l.id] = l;
                    if(needsListener) {
                        needsRender = true;
                        const itemsListener = onValue(ref(db, `${CONSTANTS.DB_PATHS.LIST_ITEMS}/${l.id}`), itemSnap => {
                            state.myListItems[l.id] = itemSnap.val() || {};
                            refreshAllGrids();
                        });
                        userListeners.push(itemsListener);
                    }
                }
                if (needsRender || removedListIds.length > 0) {
                    if (state.currentView === 'mylists') { renderMyListsPage(); }
                }
            });
            userListeners.push(listMetaListener);
        }
        
        function unsubscribeUserData() {
            userListeners.forEach(listener => listener());
            userListeners.length = 0;
            state.favorites.clear(); state.myLists = {}; state.myListItems = {};
            if (state.currentUser === null) { updateSortedArrays(); refreshAllGrids(); }
        }
        
        async function toggleFavorite(workId) {
            if (!state.currentUser) return util.showToast('ログインが必要です。');
            const favRef = ref(db, `${CONSTANTS.DB_PATHS.FAVORITES}/${state.currentUser.uid}/${workId}`);
            
            // Optimistic UI update
            const card = document.querySelector(`.item[data-canonical-id="${workId}"]`);
            if (card) card.querySelector('.favorite-btn')?.classList.toggle('favorited');

            try {
                await (state.favorites.has(workId) ? remove(favRef) : set(favRef, serverTimestamp()));
            } catch (error) {
                // Revert on error
                if (card) card.querySelector('.favorite-btn')?.classList.toggle('favorited');
                util.showToast(`お気に入り操作に失敗しました: ${error.message}`);
            }
        }
        
        async function createNewList(name) {
            if (!state.currentUser) { util.showToast('ログインが必要です。'); return null; }
            if (Object.keys(state.myLists).length >= CONSTANTS.LIST_LIMITS.MAX_LISTS) { util.showToast(`作成できるリストは${CONSTANTS.LIST_LIMITS.MAX_LISTS}個までです。`); return null; }
            const newListRef = push(ref(db, CONSTANTS.DB_PATHS.LISTS));
            await set(newListRef, { ownerId: state.currentUser.uid, ownerName: state.currentUser.displayName, name: name.trim(), createdAt: serverTimestamp() });
            await set(ref(db, `${CONSTANTS.DB_PATHS.USER_LISTS}/${state.currentUser.uid}/${newListRef.key}`), true);
            return newListRef.key;
        }
        
        async function toggleWorkInList(workId, listId, shouldBeInList) {
            if (!state.currentUser) return false;
            const itemRef = ref(db, `${CONSTANTS.DB_PATHS.LIST_ITEMS}/${listId}/${workId}`);
            if (shouldBeInList) {
                if (Object.keys(state.myListItems[listId] || {}).length >= CONSTANTS.LIST_LIMITS.MAX_ITEMS_PER_LIST) {
                    util.showToast(`リストには${CONSTANTS.LIST_LIMITS.MAX_ITEMS_PER_LIST}件まで登録できます。`);
                    const checkbox = document.querySelector(`.add-to-list-popover input[data-list-id="${listId}"]`);
                    if (checkbox) checkbox.checked = false;
                    return false;
                }
                await set(itemRef, { addedAt: serverTimestamp() });
            } else { await remove(itemRef); }
            return true;
        }
        
        async function getPublicListData(listId) {
            const listSnap = await get(child(ref(db), `${CONSTANTS.DB_PATHS.LISTS}/${listId}`));
            if (!listSnap.exists()) throw new Error("指定されたリストは見つかりませんでした。");

            const itemsSnap = await get(child(ref(db), `${CONSTANTS.DB_PATHS.LIST_ITEMS}/${listId}`));
            const items = itemsSnap.exists() ? itemsSnap.val() : {};
            const workIds = Object.keys(items);

            const workPromises = workIds.map(workId => get(child(ref(db), `${CONSTANTS.DB_PATHS.WORKS}/${workId}`)));
            const workSnapshots = await Promise.all(workPromises);

            const worksForList = {};
            workSnapshots.forEach(snap => {
                if (snap.exists()) {
                    worksForList[snap.key] = { id: snap.key, ...snap.val() };
                }
            });
            
            return { info: { id: listSnap.key, ...listSnap.val() }, items: items, works: worksForList };
        }
        
        async function importList(listId) {
            if (!state.currentUser) { util.showToast('ログインが必要です。'); return; }
            if (Object.keys(state.myLists).length >= CONSTANTS.LIST_LIMITS.MAX_LISTS) { util.showToast(`作成できるリストは${CONSTANTS.LIST_LIMITS.MAX_LISTS}個までです。`); return; }
            try {
                const { info, items } = await getPublicListData(listId);
                const newListName = `${info.name} (コピー)`;
                const newListId = await createNewList(newListName);
                if (!newListId) return;
                const itemEntries = Object.entries(items);
                if (itemEntries.length > CONSTANTS.LIST_LIMITS.MAX_ITEMS_PER_LIST) {
                    util.showToast(`コピー元リストのアイテム数が上限を超えています。先頭${CONSTANTS.LIST_LIMITS.MAX_ITEMS_PER_LIST}件のみインポートします。`);
                    itemEntries.length = CONSTANTS.LIST_LIMITS.MAX_ITEMS_PER_LIST;
                }
                const updates = {};
                itemEntries.forEach(([workId]) => { updates[`${CONSTANTS.DB_PATHS.LIST_ITEMS}/${newListId}/${workId}`] = { addedAt: serverTimestamp() }; });
                await update(ref(db), updates);
                util.showToast(`「${util.escapeHTML(newListName)}」をインポートしました。`);
                state.activeListId = newListId;
            } catch (error) { util.showToast(error.message || 'リストのインポートに失敗しました。'); }
        }
        
        function updateSortedArrays() {
            const allWorks = {...state.works, ...state.adminPicks};
            
            state.sortedWorkIds.ranking = Object.values(state.works).sort((a, b) => (b.score || 0) - (a.score || 0)).map(w => w.id);
            state.sortedWorkIds.new = Object.values(state.works).sort((a, b) => b.timestamp - a.timestamp).map(w => w.id);
            
            state.sortedWorkIds.favorites = [...state.favorites].map(favId => {
                return allWorks[favId] || Object.values(allWorks).find(p => p.pageUrl?.includes(favId));
            }).filter(Boolean) 
                .sort((a, b) => (b?.timestamp || 0) - (a?.timestamp || 0))
                .map(w => w.id);
            
            const adminPicks = Object.values(state.adminPicks).sort((a, b) => (a.order ?? a.timestamp) - (b.order ?? b.timestamp));
            state.sortedAdminIds.manga = adminPicks.filter(w => util.classifyWork(w) === 'manga').map(w => w.id);
            state.sortedAdminIds.game = adminPicks.filter(w => util.classifyWork(w) === 'game').map(w => w.id);
        }
        
        function refreshAllGrids() {
            const currentView = state.currentView;
            if (currentView === 'main' || currentView === 'publicList') {
                ['new', 'ranking', 'admin_manga', 'admin_game'].forEach(renderPage);
            } else if (currentView === 'favorites') {
                renderPage('favorites');
            } else if (currentView === 'mylists') {
                renderMyListsPage();
            }
        }
        
        function initializeListeners() {
            onValue(ref(db, CONSTANTS.DB_PATHS.CATEGORIES), (snap) => { state.categories = snap.val() || {}; });
            onValue(ref(db, CONSTANTS.DB_PATHS.TAGS), (snap) => {
                state.tags = snap.val() || {}; state.tagNameToDataMap.clear();
                Object.entries(state.tags).forEach(([id, data]) => { state.tagNameToDataMap.set(data.name, { id, ...data }); });
            });
            onValue(ref(db, CONSTANTS.DB_PATHS.WORKS), (snapshot) => {
                const newWorks = {};
                snapshot.forEach(childSnap => {
                    const data = childSnap.val();
                    newWorks[childSnap.key] = { id: childSnap.key, ...data, score: Object.values(data?.votes || {}).reduce((s, v) => s + v, 0) };
                });
                state.works = newWorks;
                state.isInitialDataLoaded.works = true;
                updateSortedArrays();
                refreshAllGrids();
            });
            onValue(ref(db, CONSTANTS.DB_PATHS.ADMIN_PICKS), (snapshot) => {
                const newAdminPicks = {};
                snapshot.forEach(childSnap => {
                    newAdminPicks[childSnap.key] = { id: childSnap.key, ...childSnap.val() };
                });
                state.adminPicks = newAdminPicks;
                state.isInitialDataLoaded.adminPicks = true;
                updateSortedArrays();
                refreshAllGrids();
            });
        }
        
        function initializePageSizeSelectors() {
            const isMobile = window.innerWidth <= 768;
            const deviceType = isMobile ? 'mobile' : 'pc';
            for (const type of ['admin', 'user', 'favorites']) {
                const selector = dom.pageSizeSelectors[type];
                if (!selector) continue;
                const options = CONSTANTS.PAGE_SIZE_OPTIONS[deviceType][type];
                let currentSize = state.pageSize[type];
                if (!options.includes(currentSize)) { currentSize = options[0]; }
                selector.innerHTML = '';
                options.forEach(size => {
                    const option = document.createElement('option');
                    option.value = size; option.textContent = size;
                    if (size == currentSize) { option.selected = true; }
                    selector.appendChild(option);
                });
            }
        }
        
        function setupCollapsers() {
            document.querySelectorAll('.collapser-header').forEach(header => {
                const content = header.nextElementSibling;
                if (!content || !content.classList.contains('collapsible-content')) return;
                const sectionName = header.dataset.section;
                if (state.sectionsCollapsed[sectionName]) { header.classList.add('collapsed'); content.classList.add('collapsed'); }
                header.addEventListener('click', (e) => {
                    if (e.target.tagName === 'SELECT' || e.target.tagName === 'LABEL') return;
                    const isCollapsed = header.classList.toggle('collapsed');
                    content.classList.toggle('collapsed');
                    state.sectionsCollapsed[sectionName] = isCollapsed;
                    localStorage.setItem(`${sectionName}SectionCollapsed`, isCollapsed);
                });
            });
        }
        
        function setupEventListeners() {
            dom.loginBtn.addEventListener('click', () => { const p = new GoogleAuthProvider(); signInWithPopup(auth, p).catch(err => util.showToast(`Login failed: ${err.code}`)); });
            dom.logoutBtn.addEventListener('click', () => signOut(auth));
            dom.nav.home.addEventListener('click', () => showView('main'));
            dom.nav.favorites.addEventListener('click', () => showView('favorites'));
            dom.nav.mylists.addEventListener('click', () => showView('mylists'));
            
            dom.importPublicListBtn.addEventListener('click', (e) => importList(e.currentTarget.dataset.listId));
            document.getElementById('addBtn').addEventListener("click", () => addWork(dom.urlInput.value.trim()));
            dom.pageSizeSelectors.admin.addEventListener('change', (e) => { state.pageSize.admin = parseInt(e.target.value, 10); localStorage.setItem('pageSizeAdmin', state.pageSize.admin); renderPage('admin_manga'); renderPage('admin_game'); });
            dom.pageSizeSelectors.user.addEventListener('change', (e) => { state.pageSize.user = parseInt(e.target.value, 10); localStorage.setItem('pageSizeUser', state.pageSize.user); renderPage('new'); renderPage('ranking'); });
            dom.pageSizeSelectors.favorites.addEventListener('change', (e) => { state.pageSize.favorites = parseInt(e.target.value, 10); localStorage.setItem('pageSizeFavorites', state.pageSize.favorites); renderPage('favorites'); });
            dom.modalOverlay.addEventListener("click", (e) => { if (e.target === dom.modalOverlay) dom.modalOverlay.classList.add("hidden"); });
            
            const mosaicToggleBtn = document.getElementById('mosaicToggleBtn');
            const hideBadBtn = document.getElementById('hideBadBtn');

            // PC Controls
            document.getElementById('infoBtn').addEventListener('click', openInfoModal);
            hideBadBtn.addEventListener("click", () => { 
                state.hideBadlyRated = !state.hideBadlyRated; 
                hideBadBtn.classList.toggle('active', state.hideBadlyRated); 
                const mobileBtn = dom.mobileMenu.querySelector('[data-action="toggle-bad"]');
                hideBadBtn.textContent = state.hideBadlyRated ? 'Bad評価を再表示' : 'Bad評価を非表示';
                if (mobileBtn) mobileBtn.textContent = hideBadBtn.textContent;
                renderPage('new'); renderPage('ranking');
            });
            mosaicToggleBtn.addEventListener("click", () => {
                state.mosaicActive = !state.mosaicActive;
                localStorage.setItem('mosaicActive', state.mosaicActive);
                document.body.classList.toggle('mosaic-on', state.mosaicActive);
                const text = state.mosaicActive ? 'モザイク OFF' : 'モザイク ON';
                mosaicToggleBtn.textContent = text;
                const mobileBtn = dom.mobileMenu.querySelector('[data-action="toggle-mosaic"]');
                if (mobileBtn) mobileBtn.textContent = text;
            });
            document.querySelectorAll('.filterByTagsBtn').forEach(btn => btn.addEventListener('click', openTagFilterModal));
            document.querySelectorAll('.resetFilterBtn').forEach(btn => btn.addEventListener('click', () => { 
                state.highlightTagIds.clear(); 
                state.hideTagIds.clear(); 
                refreshAllGrids();
            }));
            document.getElementById('contactBtn').addEventListener('click', openContactModal);
            
            // Mobile Controls
            dom.hamburgerBtn.addEventListener('click', () => {
                dom.mobileMenu.classList.toggle('hidden');
            });
            dom.mobileMenu.addEventListener('click', (e) => {
                if (e.target.tagName !== 'BUTTON') return;
                const action = e.target.dataset.action;
                switch(action) {
                    case 'contact': openContactModal(); break;
                    case 'filter-tags': openTagFilterModal(); break;
                    case 'reset-filter': 
                        document.querySelectorAll('.resetFilterBtn').forEach(b => b.click());
                        break;
                    case 'toggle-bad': hideBadBtn.click(); break;
                    case 'toggle-mosaic': mosaicToggleBtn.click(); break;
                    case 'info': openInfoModal(); break;
                }
                dom.mobileMenu.classList.add('hidden');
            });
            
            // Other Listeners
            document.getElementById('toggle-sidebar-btn').addEventListener('click', (e) => {
                const isCollapsed = dom.mylistsContainer.classList.toggle('sidebar-collapsed');
                e.currentTarget.textContent = isCollapsed ? '▶' : '◀';
            });
        }

        function setupDelegatedEventListeners() {
            dom.container.addEventListener('click', (e) => {
                const target = e.target;
                
                // --- Item Card Actions ---
                const card = target.closest('.item');
                if (card) {
                    const workId = card.dataset.id;
                    const canonicalId = card.dataset.canonicalId;

                    if (target.closest('.rating-btn')) {
                        handleVote(workId);
                    } else if (target.closest('.favorite-btn')) {
                        e.stopPropagation();
                        toggleFavorite(canonicalId);
                    } else if (target.closest('.add-to-list-btn')) {
                        e.stopPropagation();
                        openAddToListPopover(canonicalId, target);
                    } else if (target.closest('.remove-from-list-btn')) {
                        e.stopPropagation();
                        const listId = target.dataset.listId;
                        if (confirm(`「${util.escapeHTML(state.myLists[listId]?.name || '')}」からこの作品を削除しますか？`)) {
                            removeWorkFromList(canonicalId, listId);
                        }
                    } else {
                        const workData = state.works[workId] || state.adminPicks[workId];
                        if(workData && workData.pageUrl) {
                            window.open(workData.pageUrl, "_blank");
                        }
                    }
                    return; // Card action handled, no need to check others
                }

                const paginationButton = target.closest('.pagination button');
                if (paginationButton && !paginationButton.disabled) {
                    const paginationContainer = target.closest('.pagination');
                    const viewType = paginationContainer.dataset.viewType;
                    const newPage = parseInt(paginationButton.dataset.page, 10);
                    if (viewType && newPage) {
                        state.currentPage[viewType] = newPage;
                        renderPage(viewType);
                    }
                }
            });
        }
        
        function setupImagePreviewListeners() {
            const popup = dom.imagePreviewPopup; if (!popup || !dom.container) return;
            dom.container.addEventListener('mouseover', (e) => {
                if (window.innerWidth <= 768) return;
                if (e.target.tagName !== 'IMG' || !e.target.closest('.item')) return;
                const card = e.target.closest('.item'); const workId = card.dataset.id;
                const work = state.works[workId] || state.adminPicks[workId];
                if (work && work.coverUrl) {
                    popup.innerHTML = `<img src="${work.coverUrl}" alt="Preview">`;
                    popup.style.visibility = 'hidden'; popup.style.display = 'block';
                    const popupRect = popup.getBoundingClientRect(); const cardRect = card.getBoundingClientRect();
                    let left = cardRect.right + 10; if (left + popupRect.width > window.innerWidth) { left = cardRect.left - popupRect.width - 10; }
                    let top = cardRect.top; if (top + popupRect.height > window.innerHeight) { top = window.innerHeight - popupRect.height - 10; }
                    popup.style.left = `${left}px`; popup.style.top = `${top}px`; popup.style.visibility = 'visible';
                    e.target.addEventListener('mouseleave', () => { popup.style.display = 'none'; }, { once: true });
                }
            });
        }
        
        function updateUIforAuthState(user) {
            state.currentUser = user;
            if (user) {
                dom.loginBtn.classList.add('hidden'); dom.logoutBtn.classList.remove('hidden');
                dom.userName.textContent = user.displayName || '名無しさん'; dom.userName.classList.remove('hidden');
                document.querySelectorAll('.requires-auth').forEach(el => el.disabled = false);
            } else {
                dom.loginBtn.classList.remove('hidden'); dom.logoutBtn.classList.add('hidden');
                dom.userName.classList.add('hidden');
                document.querySelectorAll('.requires-auth').forEach(el => el.disabled = true);
            }
        }
        
        function handleUrlBasedView() {
            const params = new URLSearchParams(window.location.search);
            const listId = params.get('list'); const view = params.get('view');
            if (listId) {
                getPublicListData(listId)
                    .then(renderPublicListPage)
                    .catch(err => { console.error(err); util.showToast(err.message); showView('main'); });
            } else if (view && dom.views[view]) {
                if(dom.views[view].querySelector('.requires-auth') && !state.currentUser) {
                    showView('main');
                } else {
                    showView(view);
                }
            }
            else { showView('main'); }
        }

        function initializeDetailsPopup() {
            const popup = document.getElementById('details-popup');
            if (!popup) return;
            let hideTimeout;
            dom.container.addEventListener('mouseover', (e) => {
                if (window.innerWidth <= 768) return;
                const titleEl = e.target.closest('.title');
                if (!titleEl) return;
                clearTimeout(hideTimeout);
                const card = titleEl.closest('.item');
                const workId = card.dataset.id;
                const work = state.works[workId] || state.adminPicks[workId];
                if (!work || !work.tags || Object.keys(work.tags).length === 0) { popup.style.display = 'none'; return; }
                popup.innerHTML = `<h4>${util.escapeHTML(work.title)}</h4><div class="popup-tags">${Object.values(work.tags).map(tag => `<span class="popup-tag">${util.escapeHTML(tag)}</span>`).join('')}</div>`;
                const cardRect = card.getBoundingClientRect();
                popup.style.display = 'block';
                const popupRect = popup.getBoundingClientRect();
                let top = window.scrollY + cardRect.bottom + 5;
                let left = window.scrollX + cardRect.left;
                if (left + popupRect.width > window.innerWidth) { left = window.scrollX + cardRect.right - popupRect.width; }
                popup.style.left = `${left}px`;
                popup.style.top = `${top}px`;
            });
            dom.container.addEventListener('mouseout', (e) => {
                const titleEl = e.target.closest('.title');
                if (titleEl && e.relatedTarget !== popup) {
                    hideTimeout = setTimeout(() => { popup.style.display = 'none'; }, 200);
                }
            });
            popup.addEventListener('mouseover', () => { clearTimeout(hideTimeout); });
            popup.addEventListener('mouseout', () => { hideTimeout = setTimeout(() => { popup.style.display = 'none'; }, 200); });
        }
        
        function main() {
            ['pageSizeAdmin', 'pageSizeUser', 'pageSizeFavorites'].forEach(key => {
                const savedSize = localStorage.getItem(key);
                if (savedSize) {
                    const type = key.replace('pageSize', '').toLowerCase();
                    state.pageSize[type] = parseInt(savedSize, 10);
                }
            });
            state.sectionsCollapsed.admin = localStorage.getItem('adminSectionCollapsed') === 'true';
            state.sectionsCollapsed.user = localStorage.getItem('userSectionCollapsed') === 'true';
            if (localStorage.getItem('mosaicActive') === 'true') {
                state.mosaicActive = true; document.body.classList.add('mosaic-on');
                document.getElementById('mosaicToggleBtn').textContent = 'モザイク OFF';
                dom.mobileMenu.querySelector('[data-action="toggle-mosaic"]').textContent = 'モザイク OFF';
            }
            
            initializeListeners();
            Object.values(dom.grids).forEach(grid => {
                const type = Object.keys(dom.grids).find(key => dom.grids[key] === grid);
                const isFav = type === 'favorites';
                const isAdmin = type.startsWith('admin_');
                const pageSize = isAdmin ? state.pageSize.admin : (isFav ? state.pageSize.favorites : state.pageSize.user);
                renderSkeletons(grid, pageSize);
            });


            onAuthStateChanged(auth, (user) => {
                updateUIforAuthState(user);
                if (user) {
                    subscribeUserData(user);
                } else {
                    unsubscribeUserData();
                }
                handleUrlBasedView();
            });
            
            window.addEventListener('popstate', handleUrlBasedView);

            state.clientId = util.getClientId();
            initializePageSizeSelectors();
            setupCollapsers();
            setupEventListeners();
            setupDelegatedEventListeners();
            setupImagePreviewListeners();
            initializeDetailsPopup();
        }
        
        main();
    </script>
</body>
</html>
